<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mult-UIP: Protosockets library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Protosockets library</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsock__buf.html">psock_buf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsock.html">psock</a></td></tr>
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="psock_8h.html">psock.h</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT</a>(<a class="el" href="structpsock.html">psock</a>, buffer, buffersize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga70d236d1cf34b4e21836edda60247b70">PSOCK_SEND</a>(<a class="el" href="structpsock.html">psock</a>, data, datalen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab0ad55aa96dd1d200cd0fc5a99f6a4f7">PSOCK_SEND_STR</a>(<a class="el" href="structpsock.html">psock</a>, str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a null-terminated string.  <a href="#gab0ad55aa96dd1d200cd0fc5a99f6a4f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga10d9a9201cba1a6db623284c475c6cea">PSOCK_GENERATOR_SEND</a>(<a class="el" href="structpsock.html">psock</a>, generator, arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate data with a function and send it.  <a href="#ga10d9a9201cba1a6db623284c475c6cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gad895ab98c54d9966ff554aa873151751">PSOCK_READBUF</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(<a class="el" href="structpsock.html">psock</a>, c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4ab2de595d36e9e55dd61f6ecd139162">PSOCK_DATALEN</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(<a class="el" href="structpsock.html">psock</a>, condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gaa87ff36af81990e6ffe20d76d5e4606f">PSOCK_WAIT_THREAD</a>(<a class="el" href="structpsock.html">psock</a>, condition)&nbsp;&nbsp;&nbsp;PT_WAIT_THREAD(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga86cc77c910c9a27b614fedf3ff8294bf">psock_init</a> (struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, char *buffer, unsigned int buffersize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga712420c615c932642b69c6c0bb8d13ac">PT_THREAD</a> (psock_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, const char *buf, unsigned int len))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga7440860cfbffad961f993737932d17d7">PT_THREAD</a> (psock_generator_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned short(*f)(void *), void *arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#gadb49ec06eee4fb369d8d3a414143bb14">PT_THREAD</a> (psock_readbuf(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3b0505ebccc87d4c1ab7b0e875d53839">PT_THREAD</a> (psock_readto(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned char c))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipfw.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3178402dd725776415bf9745e7bf92ba">psock_datalen</a> (struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psock.html#ga3b19f65e48079d8105be2a99b5b4b2ae">psock_newdata</a> (struct <a class="el" href="structpsock.html">psock</a> *s)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The protosocket library provides an interface to the uIP stack that is similar to the traditional BSD socket interface. Unlike programs written for the ordinary uIP event-driven interface, programs written with the protosocket library are executed in a sequential fashion and does not have to be implemented as explicit state machines.</p>
<p>Protosockets only work with TCP connections.</p>
<p>The protosocket library uses <a class="el" href="group__pt.html">Pt</a> protothreads to provide sequential control flow. This makes the protosockets lightweight in terms of memory, but also means that protosockets inherits the functional limitations of protothreads. Each protosocket lives only within a single function. Automatic variables (stack variables) are not retained across a protosocket library function call.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the protosocket library uses protothreads, local variables will not always be saved across a call to a protosocket library function. It is therefore advised that local variables are used with extreme care.</dd></dl>
<p>The protosocket library provides functions for sending data without having to deal with retransmissions and acknowledgements, as well as functions for reading data without having to deal with data being split across more than one TCP segment.</p>
<p>Because each protosocket runs as a protothread, the protosocket has to be started with a call to <a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN()</a> at the start of the function in which the protosocket is used. Similarly, the protosocket protothread can be terminated by a call to <a class="el" href="group__psock.html#gafa11b2a1faf395ae2a6626e01c482d5d">PSOCK_EXIT()</a>. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga84901a5aa60040e96d272a69977edd22"></a><!-- doxytag: member="psock.h::PSOCK_BEGIN" ref="ga84901a5aa60040e96d272a69977edd22" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the protosocket protothread in a function.</p>
<p>This macro starts the protothread associated with the protosocket and must come before other protosocket calls in the function it is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket to be started. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00158">158</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d56800f82bfc7bbf53bb4a659589812"></a><!-- doxytag: member="psock.h::PSOCK_CLOSE" ref="ga5d56800f82bfc7bbf53bb4a659589812" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a protosocket.</p>
<p>This macro closes a protosocket and can only be called from within the protothread in which the protosocket lives.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket that is to be closed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00235">235</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac7cc1dba1819f7fcdaa9ff9eed5a08f4"></a><!-- doxytag: member="psock.h::PSOCK_CLOSE_EXIT" ref="gac7cc1dba1819f7fcdaa9ff9eed5a08f4" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_CLOSE_EXIT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a protosocket and exit the protosocket's protothread.</p>
<p>This macro closes a protosocket and exits the protosocket's protothread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00308">308</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ab2de595d36e9e55dd61f6ecd139162"></a><!-- doxytag: member="psock.h::PSOCK_DATALEN" ref="ga4ab2de595d36e9e55dd61f6ecd139162" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_DATALEN</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the data that was previously read.</p>
<p>This macro returns the length of the data that was previously read using <a class="el" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO()</a> or PSOCK_READ().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket holding the data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00281">281</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a264bb64ae706d53f572b1d9e4037a2"></a><!-- doxytag: member="psock.h::PSOCK_END" ref="ga4a264bb64ae706d53f572b1d9e4037a2" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_END</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declare the end of a protosocket's protothread.</p>
<p>This macro is used for declaring that the protosocket's protothread ends. It must always be used together with a matching <a class="el" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN()</a> macro.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00325">325</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa11b2a1faf395ae2a6626e01c482d5d"></a><!-- doxytag: member="psock.h::PSOCK_EXIT" ref="gafa11b2a1faf395ae2a6626e01c482d5d" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_EXIT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exit the protosocket's protothread.</p>
<p>This macro terminates the protothread of the protosocket and should almost always be used in conjunction with <a class="el" href="group__psock.html#ga5d56800f82bfc7bbf53bb4a659589812">PSOCK_CLOSE()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__psock.html#gac7cc1dba1819f7fcdaa9ff9eed5a08f4">PSOCK_CLOSE_EXIT()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00297">297</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga10d9a9201cba1a6db623284c475c6cea"></a><!-- doxytag: member="psock.h::PSOCK_GENERATOR_SEND" ref="ga10d9a9201cba1a6db623284c475c6cea" args="(psock, generator, arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_GENERATOR_SEND</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">generator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">arg</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>Pointer to the protosocket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>generator</em>&nbsp;</td><td>Pointer to the generator function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Argument to the generator function</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates data and sends it over the protosocket. This can be used to dynamically generate data for a transmission, instead of generating the data in a buffer beforehand. This function reduces the need for buffer memory. The generator function is implemented by the application, and a pointer to the function is given as an argument with the call to <a class="el" href="group__psock.html#ga10d9a9201cba1a6db623284c475c6cea" title="Generate data with a function and send it.">PSOCK_GENERATOR_SEND()</a>.</p>
<p>The generator function should place the generated data directly in the uip_appdata buffer, and return the length of the generated data. The generator function is called by the protosocket layer when the data first is sent, and once for every retransmission that is needed. </p>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00219">219</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga26ae707402e494f3895a9f012a93ea29"></a><!-- doxytag: member="psock.h::PSOCK_INIT" ref="ga26ae707402e494f3895a9f012a93ea29" args="(psock, buffer, buffersize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_INIT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">buffersize</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a protosocket.</p>
<p>This macro initializes a protosocket and must be called before the protosocket is used. The initialization also specifies the input buffer for the protosocket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket to be initialized</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>(char *) A pointer to the input buffer for the protosocket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffersize</em>&nbsp;</td><td>(unsigned int) The size of the input buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00144">144</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga55ce98ea4d6f22e9d5068b904d4d2447"></a><!-- doxytag: member="psock.h::PSOCK_NEWDATA" ref="ga55ce98ea4d6f22e9d5068b904d4d2447" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_NEWDATA</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if new data has arrived on a protosocket.</p>
<p>This macro is used in conjunction with the <a class="el" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL()</a> macro to check if data has arrived on a protosocket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00339">339</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad895ab98c54d9966ff554aa873151751"></a><!-- doxytag: member="psock.h::PSOCK_READBUF" ref="gad895ab98c54d9966ff554aa873151751" args="(psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READBUF</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read data until the buffer is full.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is read until the buffer is full..</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket from which data should be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00250">250</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab5d9c0becf7cb32d0aaef466839dd92e"></a><!-- doxytag: member="psock.h::PSOCK_READTO" ref="gab5d9c0becf7cb32d0aaef466839dd92e" args="(psock, c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_READTO</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">c</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read data up to a specified character.</p>
<p>This macro will block waiting for data and read the data into the input buffer specified with the call to <a class="el" href="group__psock.html#ga26ae707402e494f3895a9f012a93ea29">PSOCK_INIT()</a>. Data is only read until the specifieed character appears in the data stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket from which data should be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>(char) The character at which to stop reading. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00268">268</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga70d236d1cf34b4e21836edda60247b70"></a><!-- doxytag: member="psock.h::PSOCK_SEND" ref="ga70d236d1cf34b4e21836edda60247b70" args="(psock, data, datalen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">datalen</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send data.</p>
<p>This macro sends data over a protosocket. The protosocket protothread blocks until all data has been sent and is known to have been received by the remote end of the TCP connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket over which data is to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>(char *) A pointer to the data that is to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datalen</em>&nbsp;</td><td>(unsigned int) The length of the data that is to be sent. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00178">178</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab0ad55aa96dd1d200cd0fc5a99f6a4f7"></a><!-- doxytag: member="psock.h::PSOCK_SEND_STR" ref="gab0ad55aa96dd1d200cd0fc5a99f6a4f7" args="(psock, str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_SEND_STR</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">str</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>Pointer to the protosocket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to be sent.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a null-terminated string over the protosocket. </p>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00191">191</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa87ff36af81990e6ffe20d76d5e4606f"></a><!-- doxytag: member="psock.h::PSOCK_WAIT_THREAD" ref="gaa87ff36af81990e6ffe20d76d5e4606f" args="(psock, condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">condition</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;PT_WAIT_THREAD(&amp;((<a class="el" href="structpsock.html">psock</a>)-&gt;<a class="el" href="structpt.html">pt</a>), (condition))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="psock_8h_source.html#l00375">375</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ebfe5c8a7f3173714efdf2df74fc392"></a><!-- doxytag: member="psock.h::PSOCK_WAIT_UNTIL" ref="ga2ebfe5c8a7f3173714efdf2df74fc392" args="(psock, condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSOCK_WAIT_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="structpsock.html">psock</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">condition</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait until a condition is true.</p>
<p>This macro blocks the protothread until the specified condition is true. The macro <a class="el" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA()</a> can be used to check if new data arrives when the protosocket is waiting.</p>
<p>Typically, this macro is used as follows:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__pt.html#ga3d4c8bd4aada659eb34f5d2ffd3e7901">PT_THREAD</a>(thread(<span class="keyword">struct</span> <a class="code" href="structpsock.html">psock</a> *s, <span class="keyword">struct</span> <a class="code" href="structtimer.html">timer</a> *t))
 {
   <a class="code" href="group__psock.html#ga84901a5aa60040e96d272a69977edd22">PSOCK_BEGIN</a>(s);

   <a class="code" href="group__psock.html#ga2ebfe5c8a7f3173714efdf2df74fc392">PSOCK_WAIT_UNTIL</a>(s, PSOCK_NEWADATA(s) || <a class="code" href="group__timer.html#ga6d71dececfce707c668e6257aad5906e">timer_expired</a>(t));
   
   <span class="keywordflow">if</span>(<a class="code" href="group__psock.html#ga55ce98ea4d6f22e9d5068b904d4d2447">PSOCK_NEWDATA</a>(s)) {
     <a class="code" href="group__psock.html#gab5d9c0becf7cb32d0aaef466839dd92e">PSOCK_READTO</a>(s, <span class="charliteral">&#39;\n&#39;</span>);
   } <span class="keywordflow">else</span> {
     handle_timed_out(s);
   }
   
   <a class="code" href="group__psock.html#ga4a264bb64ae706d53f572b1d9e4037a2">PSOCK_END</a>(s);
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psock</em>&nbsp;</td><td>(struct psock *) A pointer to the protosocket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td>The condition to wait for. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="psock_8h_source.html#l00372">372</a> of file <a class="el" href="psock_8h_source.html">psock.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3178402dd725776415bf9745e7bf92ba"></a><!-- doxytag: member="psock.h::psock_datalen" ref="ga3178402dd725776415bf9745e7bf92ba" args="(struct psock *psock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipfw.html#ga77570ac4fcab86864fa1916e55676da2">u16_t</a> psock_datalen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&nbsp;</td>
          <td class="paramname"> <em>psock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="psock_8c_source.html#l00254">254</a> of file <a class="el" href="psock_8c_source.html">psock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga86cc77c910c9a27b614fedf3ff8294bf"></a><!-- doxytag: member="psock.h::psock_init" ref="ga86cc77c910c9a27b614fedf3ff8294bf" args="(struct psock *psock, char *buffer, unsigned int buffersize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psock_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&nbsp;</td>
          <td class="paramname"> <em>psock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>buffersize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3b19f65e48079d8105be2a99b5b4b2ae"></a><!-- doxytag: member="psock.h::psock_newdata" ref="ga3b19f65e48079d8105be2a99b5b4b2ae" args="(struct psock *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char psock_newdata </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpsock.html">psock</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="psock_8c_source.html#l00260">260</a> of file <a class="el" href="psock_8c_source.html">psock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b0505ebccc87d4c1ab7b0e875d53839"></a><!-- doxytag: member="psock.h::PT_THREAD" ref="ga3b0505ebccc87d4c1ab7b0e875d53839" args="(psock_readto(struct psock *psock, unsigned char c))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_readto(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned char c)&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadb49ec06eee4fb369d8d3a414143bb14"></a><!-- doxytag: member="psock.h::PT_THREAD" ref="gadb49ec06eee4fb369d8d3a414143bb14" args="(psock_readbuf(struct psock *psock))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_readbuf(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>)&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7440860cfbffad961f993737932d17d7"></a><!-- doxytag: member="psock.h::PT_THREAD" ref="ga7440860cfbffad961f993737932d17d7" args="(psock_generator_send(struct psock *psock, unsigned short(*f)(void *), void *arg))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_generator_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, unsigned short(*f)(void *), void *arg)&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga712420c615c932642b69c6c0bb8d13ac"></a><!-- doxytag: member="psock.h::PT_THREAD" ref="ga712420c615c932642b69c6c0bb8d13ac" args="(psock_send(struct psock *psock, const char *buf, unsigned int len))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_THREAD </td>
          <td>(</td>
          <td class="paramtype">psock_send(struct <a class="el" href="structpsock.html">psock</a> *<a class="el" href="structpsock.html">psock</a>, const char *buf, unsigned int len)&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jun 17 2011 01:55:44 for Mult-UIP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
